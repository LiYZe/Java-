# 模式

# 同步模式

## 保护性暂停模式

用在一个线程等待另一个线程的执行结果。

有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject。如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）

## 顺序控制

1.固定运行顺序

2.交替输出

## Balking

一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做，直接结束返回

# 异步模式

## 生产者/消费者模式

与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应

消费队列可以用来平衡生产和消费的线程资源

生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据

消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据

JDK 中各种阻塞队列，采用的就是这种模式

## 工作线程

让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。

不同任务类型应该使用不同的线程池，这样能够避免饥饿，并能提升效率。

### 饥饿

使用固定大小的线程池，会因为线程池数量不够，导致饥饿。

### 线程池数量

过小会导致程序不能充分地利用系统资源、容易导致饥饿

过大会导致更多的线程上下文切换，占用更多内存

#### CPU 密集型运算

通常采用cpu核数+1能够实现最优的CPU利用率，+1保证当线程暂停时，有额外的线程使用。

####  I/O 密集型运算

线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间

# 终止模式

## 两阶段终止模式

<div align="center"><img src="https://user-images.githubusercontent.com/37955886/118216002-3e22be80-b4a5-11eb-8a27-04cc86a444ea.png"/></div> 

# 享元模式

需要重用数量有限的同一类对象时。

通过尽可能的对相同值进行共享，而减少内存的使用。

















