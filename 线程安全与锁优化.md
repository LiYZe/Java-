# 线程安全

当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的

共同特征：代码本身封装了所有必要的正确性保障手段。

## Java语言中的线程安全

### 不可变

不可变的对象一定是线程安全的。

只要一个不可变的对象被正确地构建出来，即没有发生this引用逃逸的情况，那其外部的可见状态永远都不会改变，永远都不会看到它在多个线程之中处于不一致的状态。

### 绝对线程安全

一个类达到不管运行时环境如何，调用者都不需要任何额外的同步措施。

代价高。

### 相对线程安全

保证对象单次的操作是线程安全的，调用时不需要额外的保障措施。

Java语言中，大部分声称线程安全的类都属于这种类型

### 线程兼容

指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。

### 线程对立

不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。

## 线程安全的实现

### 互斥同步

同步:在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用.

互斥：实现同步的一种手段

互斥是因，同步是果；互斥是方法，同步是目的。

实现：synchronized，lock，ReentrantLock

ReentrantLock：等待可中断、可实现公平锁、锁可以绑定多个条件。

### 非阻塞同步

因为进行线程阻塞和唤醒所带来的性能开销，所以、将互斥同步也称为阻塞同步

非阻塞同步：基于冲突检测的乐观并发策略，不再需要把线程阻塞挂起，常被称为无锁

实现：CAS

### 无同步方案

有一些代码天生就是线程安全的

#### 可重入代码

代码可在任何时候被任意一段代码中断，但返回原程序后，不会出错或有任何影响

所有可重入的代码都是线程安全的，但并非所有的线程安全的代码都是可重入的。

可重入性判断：方法返回结果可预测，相同的数据产生相同的结果，既满足可重入性要求且线程安全。

#### 线程本地存储

代码中的数据必须与其他代码共享，判断能否将这些共享的代码限制在一个线程中。

# 锁优化

## 自旋锁与自适应自旋

- [自旋优化](共享模型之管程.md#自旋优化)

## 锁消除

虚拟机即时编译器在运行时，对于被要求同步的代码检测，发现不存在竞争，会将锁消除

## 锁粗化

虚拟机探测到有多个操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。

## 轻量级锁

- [轻量级锁](共享模型之管程.md#轻量级锁)

## 偏向锁

目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。

- [偏向锁](共享模型之管程.md#偏向锁)









