# Java内存模型

Java Memory Model。

定义了主存、工作内存抽象概。

# 原子性

保证指令不受到线程上下文切换影响。

# 可见性

保证指令不会受到cpu缓存影响。

## 问题

1.初始状态，线程从主从内存中读取变量的值到工作内存。

2.多次读取之后，JIT编译器会因为线程要频繁读取变量值，而将变量值存在工作内存的高速缓存中，减少对主存的访问，提高效率

3.当修改变量值并同步至主存后，线程仍然是从自己的高速缓存中读取变量值，永远是旧值。

## 解决

### volatile

用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存

能保证的是在多个线程之间，一个线程对volatile变量的修改对另一个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况：

#### 原理

底层实现原理是内存屏障，Memory Barrier（Memory Fence）。

##### 保证可见性

对volatile变量的写指令后会加入写屏障，保证在该屏障之前的，对共享变量的改动，都同步到主存当中

对volatile变量的读指令前会加入读屏障，保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据

##### 保证有序性

写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后

读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前

# 有序性

保证指令不会受到cpu指令并行优化的影响。

## 指令重排

JVM 会在不影响正确性的前提下，可以调整语句的执行顺序

### 解决

给变量添加volatile即可解决指令重排问题。

### happens-before

规定了对共享变量的写操作对其它线程的读操作可见.

是可见性与有序性的一套规则总结

1.线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见

2.线程对 volatile 变量的写，对接下来其它线程对该变量的读可见

3.线程 start 前对变量的写，对该线程开始后对该变量的读可见

4.线程结束前对变量的写，对其它线程得知它结束后的读可见

5.线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见

6.对变量默认值（0，false，null）的写，对其它线程对该变量的读可见

7.具有传递性，如果 x hb-> y 并且 y hb-> z 那么有 x hb-> z 









